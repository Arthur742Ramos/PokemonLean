native_decide Audit — PokemonLean
==================================
Date: 2026-02-20

1. COMPLETE LIST OF native_decide USAGE
========================================

All proof-closing native_decide calls (i.e., the theorem's final tactic).
Inline `by native_decide` for Fin bound proofs (e.g., ⟨2, by native_decide⟩)
are NOT counted as separate theorems — they're trivial Nat < comparisons.

FILE: PokemonLean/NashEquilibrium.lean  (13 native_decide proofs)
─────────────────────────────────────────────────────────────────
Line 157  theorem uniform3_is_mixed
Line 161  theorem symmetric_rps_uniform_is_nash
Line 168  theorem symmetric_rps_unique_uniform_on_thirds_grid
Line 206  theorem asymmetric_weights_is_mixed
Line 212  theorem asymmetric_weights_balance_pure_payoffs
Line 216  theorem asymmetric_weights_form_nash
Line 223  theorem asymmetric_unique_on_sevenths_grid
Line 311  theorem real_nash_row_is_mixed
Line 314  theorem real_nash_col_is_mixed
Line 318  theorem real_nash_value_eq_expected
Line 322  theorem real_nash_row_best_response_checks
Line 326  theorem real_nash_col_best_response_checks
Line 330  theorem real_nash_equilibrium_verified

FILE: PokemonLean/RealMetagame.lean  (9 native_decide proofs)
──────────────────────────────────────────────────────────────
Line 450  theorem mega_absol_dragapult_candidate_is_mixed
Line 454  theorem mega_absol_dragapult_value
Line 458  theorem mega_absol_dragapult_row_best_response_checks_fail
Line 462  theorem mega_absol_dragapult_col_best_response_checks_fail
Line 467  theorem raging_bolt_row_deviation_improves
Line 472  theorem raging_bolt_col_deviation_reduces
Line 476  theorem mega_absol_dragapult_not_nash
Line 491  theorem observed_not_normalized (2 calls inside)

FILE: PokemonLean/EvolutionaryDynamics.lean  (69 theorems via optimize_proof macro)
────────────────────────────────────────────────────────────────────────────────────
optimize_proof is defined as: elab "optimize_proof" : tactic => native_decide
112 additional inline `by native_decide` for Fin index construction.

Key theorems (sample):
  theorem nash_equal_fitness
  theorem nash_is_fixed_point
  theorem dominated_below_avg_fitness
  theorem rps_combo_increases_step1
  theorem dragapult_negative_fitness
  theorem grimmsnarl_positive_fitness
  theorem real_cycle_no_extinction_iter3
  theorem ceruledge_share_decreases
  ... (69 total)

FILE: PokemonLean/SharePerturbation.lean  (7 theorems via optimize_proof/_native)
─────────────────────────────────────────────────────────────────────────────────
Line 66   theorem top14_share_total
Line 70   theorem paradox_holds_drag_at_10pct
Line 74   theorem paradox_holds_drag_at_5pct
Line 81   theorem grimmsnarl_stays_best_at_15pct
Line 85   theorem paradox_independent_of_popularity  (part 1)
Line 90   theorem paradox_independent_of_popularity  (part 2)
Line 96   theorem (additional share theorem)

TOTAL: ~98 theorems closed by native_decide across the codebase.


2. CAN `decide` REPLACE `native_decide`?
==========================================

ANSWER: NO — not for any theorem in this codebase.

Root cause: The kernel cannot reduce `Fin.foldl`.

Every computational theorem uses `sumFin`, which is defined as:
  def sumFin (m : Nat) (f : Fin m → Rat) : Rat :=
    Fin.foldl m (fun acc i => acc + f i) 0

`Fin.foldl` is implemented via `Fin.foldl.loop`, which is compiled
but NOT marked @[reducible] — the kernel treats it as opaque.

When `decide` attempts to evaluate the Decidable instance, it gets stuck at:
  match (Fin.foldl.loop 3 (fun acc i => acc + uniform3 i) 0 0).num, ...
and reports "reduction got stuck at the Decidable instance."

This is not a performance issue — it is a STRUCTURAL impossibility.
The kernel literally cannot step through `Fin.foldl.loop`.

Tested:
  ✗ decide on IsMixedStrategy 3 uniform3         → STUCK (instant failure)
  ✗ simp [...] then decide                        → stack overflow / heartbeat timeout
  ✗ unfold + decide                               → stuck on Fin.foldl
  ✓ decide on raw Rat arithmetic (1/3+1/3+1/3=1)  → works instantly

The only way to use `decide` would be to rewrite ALL definitions to avoid
Fin.foldl (e.g., use explicit recursive sums or List.sum). This would
require rewriting the entire computational core of the project.


3. NASH THEOREM SPECIFICALLY
==============================

theorem real_nash_equilibrium_verified (NashEquilibrium.lean:330):
  Cannot use `decide`. Uses 14×14 matrix with Rat entries.
  Even if Fin.foldl were kernel-reducible, the 14×14 game would
  likely be prohibitively slow for kernel evaluation (196 Rat
  multiplications per payoff computation × 28 best-response checks).

  native_decide builds this in the normal build (seconds).
  decide is structurally impossible due to Fin.foldl.


4. RECOMMENDATION FOR THE PAPER
=================================

State honestly:

  "All computational verifications use Lean 4's `native_decide` tactic,
   which compiles the decision procedure to native code and trusts the
   compiler. This introduces a trust assumption on the Lean compiler
   (analogous to the trust assumption in any proof assistant's code
   generation). The kernel-checked `decide` tactic cannot be used because
   `Fin.foldl`, which underlies all our finite summations, is not
   reducible in Lean's kernel — this is a known limitation of Lean 4's
   kernel reduction, not a deficiency of our proofs.

   We note that the logical content of every theorem is independently
   checkable: each proof reduces to decidable rational arithmetic on
   concrete finite structures. The `native_decide` tactic merely
   automates this evaluation."

Alternative shorter version:

  "Computational proofs are closed by `native_decide`, which compiles
   decidability witnesses to native code. Kernel-checked `decide` is
   precluded by `Fin.foldl` opacity in Lean 4's kernel, not by proof
   complexity."
